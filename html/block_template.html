<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>VHDL Visualizer – Block</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    html, body { height: 100%; margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, sans-serif; }
    #app { display:grid; grid-template-columns: 360px 1fr; height:100%; }
    #sidebar { border-right:1px solid #ddd; padding:12px; overflow:auto; }
    #toolbar { display:flex; gap:8px; align-items:center; margin-bottom:10px; }
    #canvas { position:relative; }
    #elk { width: 100%; height: 100%; }
    .btn { padding:6px 10px; border:1px solid #ccc; border-radius:8px; background:#f6f6f6; cursor:pointer; }
    .section { margin: 12px 0; }
    .tag { display:inline-block; padding:2px 6px; border:1px solid #ddd; border-radius:6px; margin:2px; font-size:12px; }
    .key { font-weight:600; }
    .hint { color:#666; font-size:12px; }
    #tip { position: fixed; pointer-events: none; background: #111; color:#fff; padding:6px 8px; border-radius:6px; font-size:12px; opacity:0; transition:opacity .08s ease; max-width: 460px; }
    .dim { opacity: 0.12 }
  </style>
  <script src="https://unpkg.com/elkjs@0.9.3/lib/elk.bundled.js"></script>
  <script> const DATA = /*__BLOCK_DATA__*/ </script>
</head>
<body>
<div id="app">
  <div id="sidebar">
    <div id="toolbar">
      <label><input type="checkbox" id="groupBuses" checked> Group buses</label>
      <button class="btn" id="resetView">Reset view</button>
    </div>
    <div class="section"><span class="key">Block:</span> <span id="ent"></span></div>
    <div class="section"><div class="key">File</div><div><code id="path"></code></div></div>
    <div class="section">
      <div class="key">Ports</div><div id="ports"></div>
    </div>
    <div class="section">
      <div class="key">Signals</div><div id="signals"></div>
    </div>
    <div class="section">
      <div class="key">Instances</div><div id="instances"></div>
    </div>
    <div class="section hint">
      • **Inputs drive the design**; outputs are sinks.<br>
      • Hover edges to see exact pins; click an edge to isolate; ESC to clear.<br>
      • Turn off “Group buses” to see every slice separately.
    </div>
  </div>
  <div id="canvas"><svg id="elk"></svg></div>
</div>
<div id="tip"></div>

<script>
  // Sidebar basics
  ent.textContent = DATA.file.entity;
  path.textContent = DATA.file.path;
  DATA.ports.forEach(p => { const s=document.createElement('span'); s.className='tag'; s.textContent=`${p.name}: ${p.direction} ${p.dtype}`; ports.appendChild(s); });
  DATA.signals.forEach(sg => { const s=document.createElement('span'); s.className='tag'; s.textContent=`${sg.name}: ${sg.dtype}`; signals.appendChild(s); });
  DATA.instances.forEach(i => {
    const div=document.createElement('div'); div.style.margin='6px 0';
    const head=document.createElement('div');
    head.innerHTML=`<span class="key">${i.label}</span> : ${(i.entity_ref||i.component_name||'?')}`;
    div.appendChild(head);
    if (i.port_map && Object.keys(i.port_map).length){
      const pm=document.createElement('div'); pm.style.fontSize='12px'; pm.style.color='#333';
      pm.textContent=Object.entries(i.port_map).map(([k,v])=>`${k}=>${v}`).join(', ');
      div.appendChild(pm);
    }
    instances.appendChild(div);
  });

  // Layout data
  const NODES = DATA.graph.nodes;
  const EDGES = DATA.graph.edges;

  // Node styles / ranks
  function nodeStyle(kind){
    if (kind === 'instance') return {w: 220, h: 100, fill:'#eef3ff', stroke:'#99b2ff', rx:12};
    if (kind === 'entity_in') return {w: 150, h: 36, fill:'#e8fff1', stroke:'#70c790', rx:10};
    if (kind === 'entity_out') return {w: 150, h: 36, fill:'#fff1e8', stroke:'#e6a265', rx:10};
    if (kind === 'entity_bi') return {w: 150, h: 36, fill:'#fffbe6', stroke:'#d0c05a', rx:10};
    if (kind === 'const') return {w: 100, h: 28, fill:'#f4f4f4', stroke:'#bbb', rx:10};
    if (kind === 'expr') return {w: 190, h: 28, fill:'#f9f9f9', stroke:'#bbb', rx:10};
    return {w: 120, h: 30, fill:'#f4f4f4', stroke:'#bbb', rx:10};
  }
  function rank(kind){
    if (kind === 'entity_in' || kind === 'const' || kind === 'expr') return 0;    // sources (left)
    if (kind === 'instance') return 1;
    if (kind === 'entity_out' || kind === 'entity_bi') return 2;                  // sinks (right)
    return 1;
  }

  // Build ELK input
  const elk = new ELK();
  const g = {
    id: "root",
    layoutOptions: {
      'elk.algorithm':'layered',
      'elk.direction':'RIGHT',
      'elk.layered.spacing.nodeNodeBetweenLayers':'90',
      'elk.spacing.componentComponent':'70',
      'elk.edgeRouting':'SPLINES'
    },
    children: NODES.map(n => ({
      id: n.id,
      width: nodeStyle(n.kind).w,
      // Instance height grows with pin count
      height: n.kind === 'instance'
        ? Math.max(80, 24 + 16 * Math.max((n.inputs||[]).length, (n.outputs||[]).length))
        : nodeStyle(n.kind).h,
      labels: [{text: n.label}],
      layoutOptions: {'elk.layered.nodePlacement.bk.fixedAlignment': String(rank(n.kind))}
    })),
    // Edges are added after we compute pin anchors; keep metadata here
    edges: EDGES.map(e => ({ id:e.id, sources:[e.source], targets:[e.target],
                              labels:[{text:e.label}], base:e.base||e.label,
                              src_pin:e.src_pin||"", dst_pin:e.dst_pin||"",
                              bundle_idx:e.bundle_idx||0, bundle_n:e.bundle_n||1 }))
  };

  // Drawing
  elk.layout(g).then(lg => {
    const svg = document.getElementById('elk');
    const NS = "http://www.w3.org/2000/svg";
    svg.setAttribute('viewBox', `0 0 ${lg.width+80} ${lg.height+80}`);

    // Pin anchor map: nodeId -> {in:{pin: y}, out:{pin: y}}
    const ANCH = {};

    function recordPin(nodeId, side, pin, y){
      ANCH[nodeId] ||= {in:{}, out:{}};
      ANCH[nodeId][side][pin] = y;
    }

    function drawInstance(n, nodeData){
      const st = nodeStyle('instance');
      const group = document.createElementNS(NS, 'g');
      group.setAttribute('transform', `translate(${n.x+40}, ${n.y+40})`);

      const rect = document.createElementNS(NS, 'rect');
      rect.setAttribute('width', n.width); rect.setAttribute('height', n.height);
      rect.setAttribute('fill', st.fill); rect.setAttribute('stroke', st.stroke);
      rect.setAttribute('rx', st.rx); rect.setAttribute('ry', st.rx);
      group.appendChild(rect);

      // Title
      const t = document.createElementNS(NS, 'text');
      t.setAttribute('x', 8); t.setAttribute('y', 16);
      t.setAttribute('font-size', '12'); t.textContent = nodeData.label;
      group.appendChild(t);

      // Pins
      const ins = nodeData.inputs || [], outs = nodeData.outputs || [];
      const rows = Math.max(ins.length, outs.length);
      const top = 30, rowH = 16;

      for (let i=0;i<rows;i++){
        const y = top + i*rowH;
        // left pin (input or empty)
        if (i < ins.length){
          const pin = ins[i];
          const dotL = document.createElementNS(NS, 'circle');
          dotL.setAttribute('cx', 0); dotL.setAttribute('cy', y); dotL.setAttribute('r', 3);
          dotL.setAttribute('fill', '#70c790'); group.appendChild(dotL);
          const lbl = document.createElementNS(NS, 'text');
          lbl.setAttribute('x', 6); lbl.setAttribute('y', y+4);
          lbl.setAttribute('font-size', '11'); lbl.textContent = pin; group.appendChild(lbl);
          recordPin(n.id, 'in', nodeData.id ? pin : pin, n.y+40 + y);
        }
        // right pin (output or empty)
        if (i < outs.length){
          const pin = outs[i];
          const dotR = document.createElementNS(NS, 'circle');
          dotR.setAttribute('cx', n.width); dotR.setAttribute('cy', y); dotR.setAttribute('r', 3);
          dotR.setAttribute('fill', '#e6a265'); group.appendChild(dotR);
          const lbl = document.createElementNS(NS, 'text');
          lbl.setAttribute('x', n.width - 6); lbl.setAttribute('y', y+4);
          lbl.setAttribute('font-size', '11'); lbl.setAttribute('text-anchor', 'end');
          lbl.textContent = pin; group.appendChild(lbl);
          recordPin(n.id, 'out', nodeData.id ? pin : pin, n.y+40 + y);
        }
      }

      svg.appendChild(group);
    }

    function drawSimple(n, kind){
      const st = nodeStyle(kind);
      const group = document.createElementNS(NS, 'g');
      group.setAttribute('transform', `translate(${n.x+40}, ${n.y+40})`);
      const rect = document.createElementNS(NS, 'rect');
      rect.setAttribute('width', n.width); rect.setAttribute('height', n.height);
      rect.setAttribute('fill', st.fill); rect.setAttribute('stroke', st.stroke);
      if (st.rx){ rect.setAttribute('rx', st.rx); rect.setAttribute('ry', st.rx); }
      group.appendChild(rect);
      if (n.labels){
        const t = document.createElementNS(NS, 'text');
        t.setAttribute('x', 8); t.setAttribute('y', 18);
        t.setAttribute('font-size', '12'); t.textContent = n.labels[0].text;
        group.appendChild(t);
      }
      svg.appendChild(group);
    }

    // Build a nodeData map aligned with lg.children
    const NODEDATA = {};
    for (const n of lg.children){
      const orig = NODES.find(x => x.id === n.id) || {kind:'other', inputs:[], outputs:[], label:n.labels?.[0]?.text || ''};
      NODEDATA[n.id] = { id: n.id, kind: orig.kind, inputs: orig.inputs||[], outputs: orig.outputs||[], label: orig.label, w: n.width, h: n.height, x: n.x+40, y: n.y+40 };
    }

    // Draw nodes and collect pin anchors
    for (const n of lg.children){
      const nd = NODEDATA[n.id];
      if (nd.kind === 'instance') drawInstance(n, nd);
      else drawSimple(n, nd.kind);
    }

    // Helpers to compute edge endpoints
    function rightSidePoint(n){ return { x: n.x + n.w, y: n.y + n.h/2 }; }
    function leftSidePoint(n){ return { x: n.x, y: n.y + n.h/2 }; }

    function getAnchor(nodeId, isSource, pinName){
      const nd = NODEDATA[nodeId];
      if (!nd) return { x: 0, y: 0 };
      if (nd.kind === 'instance' && pinName){
        // sources leave from right pins, sinks enter at left pins
        if (isSource){
          const y = ANCH[nodeId]?.out?.[pinName];
          if (y !== undefined) return { x: nd.x + nd.w, y };
        } else {
          const y = ANCH[nodeId]?.in?.[pinName];
          if (y !== undefined) return { x: nd.x, y };
        }
      }
      // fallback to center sides
      return isSource ? rightSidePoint(nd) : leftSidePoint(nd);
    }

    // Create defs (arrow)
    const defs = document.createElementNS(NS, 'defs');
    const marker = document.createElementNS(NS, 'marker');
    marker.setAttribute('id','arrow'); marker.setAttribute('markerWidth','10');
    marker.setAttribute('markerHeight','7'); marker.setAttribute('refX','10');
    marker.setAttribute('refY','3.5'); marker.setAttribute('orient','auto');
    const arrow = document.createElementNS(NS, 'polygon');
    arrow.setAttribute('points','0 0, 10 3.5, 0 7'); arrow.setAttribute('fill','#999');
    marker.appendChild(arrow); defs.appendChild(marker); svg.appendChild(defs);

    const tip = document.getElementById('tip');
    function setTip(x,y,html){ tip.style.left = (x+12)+'px'; tip.style.top = (y+12)+'px'; tip.innerHTML = html; tip.style.opacity = 1; }
    function hideTip(){ tip.style.opacity = 0; }

    // Render edges (with bus grouping toggle)
    function renderEdges(){
      // Clear old edges/text
      [...svg.querySelectorAll('path[data-edge], text[data-edgelabel]')].forEach(el => el.remove());

      const groupBuses = document.getElementById('groupBuses').checked;

      if (groupBuses){
        // Group by (source,target,base)
        const groups = {};
        for (const e of lg.edges){
          const key = `${e.sources[0]}→${e.targets[0]}#${e.base||e.labels?.[0]?.text||''}`;
          (groups[key] ||= []).push(e);
        }
        Object.values(groups).forEach(group => {
          const e = group[0];
          const sId = e.sources[0], tId = e.targets[0];
          const s = getAnchor(sId, true, e.src_pin?.split('.').slice(-1)[0] || '');
          const t = getAnchor(tId, false, e.dst_pin?.split('.').slice(-1)[0] || '');
          // simple single curve
          const path = document.createElementNS(NS, 'path');
          const d = `M ${s.x} ${s.y} C ${s.x+60} ${s.y}, ${t.x-60} ${t.y}, ${t.x} ${t.y}`;
          path.setAttribute('d', d);
          path.setAttribute('fill','none'); path.setAttribute('stroke','#666'); path.setAttribute('stroke-width','2.2');
          path.setAttribute('marker-end','url(#arrow)');
          path.setAttribute('data-edge','1');
          path.dataset.source = sId; path.dataset.target = tId;

          // label: base [N]
          const base = e.base || e.labels?.[0]?.text || '';
          const lbl = document.createElementNS(NS, 'text');
          const midx = (s.x + t.x) / 2, midy = (s.y + t.y) / 2 - 6;
          lbl.setAttribute('x', midx); lbl.setAttribute('y', midy);
          lbl.setAttribute('font-size','11'); lbl.setAttribute('text-anchor','middle');
          lbl.setAttribute('fill','#444'); lbl.setAttribute('data-edgelabel','1');
          lbl.textContent = `${base} [${group.length}]`;

          // tooltip lists all signals with pins
          path.addEventListener('mousemove', ev => {
            const list = group.map(g => {
              const name = g.labels?.[0]?.text || '';
              const meta = (g.src_pin && g.dst_pin) ? `${g.src_pin} → ${g.dst_pin}` : '';
              return `<div>${name}${meta ? ` <span class="hint">(${meta})</span>`:''}</div>`;
            }).join('');
            setTip(ev.clientX, ev.clientY, `<div style="font-weight:600">${base} [${group.length}]</div>${list}`);
          });
          path.addEventListener('mouseleave', hideTip);

          // isolate on click
          path.addEventListener('click', () => isolateEdges(new Set(group.map(x => x.id)), new Set([sId,tId])));

          svg.appendChild(path); svg.appendChild(lbl);
        });

      } else {
        // No grouping: draw each edge, fan multiple between same pair by offset
        const pairGroups = {};
        for (const e of lg.edges){
          const key = e.sources[0] + '→' + e.targets[0];
          (pairGroups[key] ||= []).push(e);
        }
        const OFFSET_STEP = 12;

        Object.values(pairGroups).forEach(group => {
          const n = group.length;
          group.forEach((e, k) => {
            const sId = e.sources[0], tId = e.targets[0];
            const srcPin = e.src_pin?.split('.').slice(-1)[0] || '';
            const dstPin = e.dst_pin?.split('.').slice(-1)[0] || '';
            const s = getAnchor(sId, true, srcPin);
            const t = getAnchor(tId, false, dstPin);
            const offset = (k - (n-1)/2) * OFFSET_STEP;

            const path = document.createElementNS(NS, 'path');
            const c1x = s.x + 60, c1y = s.y + offset;
            const c2x = t.x - 60, c2y = t.y + offset;
            const d = `M ${s.x} ${s.y} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${t.x} ${t.y}`;
            path.setAttribute('d', d);
            path.setAttribute('fill','none'); path.setAttribute('stroke','#999'); path.setAttribute('stroke-width','1.5');
            path.setAttribute('marker-end','url(#arrow)');
            path.setAttribute('data-edge','1');
            path.dataset.edgeId = e.id;
            path.dataset.source = sId; path.dataset.target = tId;

            const midx = (s.x + t.x) / 2, midy = (s.y + t.y) / 2 + offset - 6;
            const lbl = document.createElementNS(NS, 'text');
            lbl.setAttribute('x', midx); lbl.setAttribute('y', midy);
            lbl.setAttribute('font-size','11'); lbl.setAttribute('text-anchor','middle');
            lbl.setAttribute('fill','#555'); lbl.setAttribute('data-edgelabel','1');
            lbl.textContent = e.labels?.[0]?.text || '';

            // tooltip
            path.addEventListener('mousemove', ev => {
              const meta = (e.src_pin && e.dst_pin) ? `${e.src_pin} → ${e.dst_pin}` : '';
              setTip(ev.clientX, ev.clientY, `<div style="font-weight:600">${lbl.textContent}</div>${meta ? `<div class="hint">${meta}</div>`:''}`);
            });
            path.addEventListener('mouseleave', hideTip);

            // isolate on click
            path.addEventListener('click', () => isolateEdges(new Set([e.id]), new Set([sId,tId])));

            svg.appendChild(path); svg.appendChild(lbl);
          });
        });
      }
    }

    // Isolate edges/nodes
    function isolateEdges(edgeIds, nodeIds){
      const allEdges = [...svg.querySelectorAll('path[data-edge]')];
      const allLabels = [...svg.querySelectorAll('text[data-edgelabel]')];
      const allNodes = lg.children.map(n => n.id);

      allEdges.forEach(p => p.classList.toggle('dim', !edgeIds.has(p.dataset.edgeId || '')));
      allLabels.forEach(t => t.classList.toggle('dim', !edgeIds.has(t.dataset.edgeId || '')));
      for (const n of allNodes){
        const isInvolved = nodeIds.has(n);
        // dim corresponding <g> by proximity: simple approach, dim all non-involved labels/rects
      }
      // Dim node groups by drawing an overlay: simpler — dim everything then undim involved?
      // Since nodes are not grouped with IDs, keep isolation to edges for now (effective for readability).
    }

    // First render
    renderEdges();

    // Handlers
    document.getElementById('groupBuses').addEventListener('change', renderEdges);
    document.getElementById('resetView').addEventListener('click', () => {
      // clear isolation dimming
      [...svg.querySelectorAll('.dim')].forEach(el => el.classList.remove('dim'));
    });
    window.addEventListener('keydown', e => { if (e.key === 'Escape'){ [...svg.querySelectorAll('.dim')].forEach(el => el.classList.remove('dim')); hideTip(); }});
  });
</script>
</body>
</html>
