<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>VHDL Visualizer – Block</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    html, body { height: 100%; margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, sans-serif; }
    #app { display:grid; grid-template-columns: 360px 1fr; height:100%; }
    #sidebar { border-right:1px solid #ddd; padding:12px; overflow:auto; }
    #toolbar { display:flex; gap:8px; align-items:center; margin-bottom:10px; }
    #canvas { position:relative; }
    #elk { width: 100%; height: 100%; }
    .btn { padding:6px 10px; border:1px solid #ccc; border-radius:8px; background:#f6f6f6; cursor:pointer; }
    .section { margin: 12px 0; }
    .tag { display:inline-block; padding:2px 6px; border:1px solid #ddd; border-radius:6px; margin:2px; font-size:12px; }
    .key { font-weight:600; }
    .hint { color:#666; font-size:12px; }
    #tip { position: fixed; pointer-events: none; background: #111; color:#fff; padding:6px 8px; border-radius:6px; font-size:12px; opacity:0; transition:opacity .08s ease; max-width: 460px; }
    .dim { opacity: 0.15 }
    .hi-edge { stroke: #3b82f6 !important; stroke-width: 3 !important; }
    .hi-node rect { stroke: #3b82f6 !important; stroke-width: 2.5 !important; }
  </style>
  <script src="https://unpkg.com/elkjs@0.9.3/lib/elk.bundled.js"></script>
  <script> const DATA = /*__BLOCK_DATA__*/ </script>
</head>
<body>
<div id="app">
  <div id="sidebar">
    <div id="toolbar">
      <label><input type="checkbox" id="groupBuses" checked> Group buses</label>
      <button class="btn" id="resetView">Reset view</button>
    </div>
    <div class="section"><span class="key">Block:</span> <span id="ent"></span></div>
    <div class="section"><div class="key">File</div><div><code id="path"></code></div></div>
    <div class="section">
      <div class="key">Ports</div><div id="ports"></div>
    </div>
    <div class="section">
      <div class="key">Signals</div><div id="signals"></div>
    </div>
    <div class="section">
      <div class="key">Instances</div><div id="instances"></div>
    </div>
    <div class="section hint">
      • Inputs drive the design; outputs are sinks.<br>
      • Hover edges to see pins; click edges/nodes to highlight; ESC or Reset to clear.<br>
      • “Group buses” shows one edge per base with a count; turn off for per-slice edges.
    </div>
  </div>
  <div id="canvas"><svg id="elk"></svg></div>
</div>
<div id="tip"></div>

<script>
  // Sidebar basics
  ent.textContent = DATA.file.entity;
  path.textContent = DATA.file.path;
  DATA.ports.forEach(p => { const s=document.createElement('span'); s.className='tag'; s.textContent=`${p.name}: ${p.direction} ${p.dtype}`; ports.appendChild(s); });
  DATA.signals.forEach(sg => { const s=document.createElement('span'); s.className='tag'; s.textContent=`${sg.name}: ${sg.dtype}`; signals.appendChild(s); });
  DATA.instances.forEach(i => {
    const div=document.createElement('div'); div.style.margin='6px 0';
    const head=document.createElement('div');
    head.innerHTML=`<span class="key">${i.label}</span> : ${(i.entity_ref||i.component_name||'?')}`;
    div.appendChild(head);
    if (i.port_map && Object.keys(i.port_map).length){
      const pm=document.createElement('div'); pm.style.fontSize='12px'; pm.style.color='#333';
      pm.textContent=Object.entries(i.port_map).map(([k,v])=>`${k}=>${v}`).join(', ');
      div.appendChild(pm);
    }
    instances.appendChild(div);
  });

  // Layout data
  const NODES = DATA.graph.nodes;
  const EDGES = DATA.graph.edges;

  function nodeStyle(kind){
    if (kind === 'instance') return {w: 220, h: 100, fill:'#eef3ff', stroke:'#99b2ff', rx:12};
    if (kind === 'entity_in') return {w: 150, h: 36, fill:'#e8fff1', stroke:'#70c790', rx:10};
    if (kind === 'entity_out') return {w: 150, h: 36, fill:'#fff1e8', stroke:'#e6a265', rx:10};
    if (kind === 'entity_bi') return {w: 150, h: 36, fill:'#fffbe6', stroke:'#d0c05a', rx:10};
    if (kind === 'const') return {w: 100, h: 28, fill:'#f4f4f4', stroke:'#bbb', rx:10};
    if (kind === 'expr') return {w: 190, h: 28, fill:'#f9f9f9', stroke:'#bbb', rx:10};
    return {w: 120, h: 30, fill:'#f4f4f4', stroke:'#bbb', rx:10};
  }
  function rank(kind){
    if (kind === 'entity_in' || kind === 'const' || kind === 'expr') return 0;
    if (kind === 'instance') return 1;
    if (kind === 'entity_out' || kind === 'entity_bi') return 2;
    return 1;
  }

  const elk = new ELK();
  const g = {
    id: "root",
    layoutOptions: {
      'elk.algorithm':'layered',
      'elk.direction':'RIGHT',
      'elk.layered.spacing.nodeNodeBetweenLayers':'90',
      'elk.spacing.componentComponent':'70',
      'elk.edgeRouting':'SPLINES'
    },
    children: NODES.map(n => ({
      id: n.id,
      width: nodeStyle(n.kind).w,
      height: n.kind === 'instance'
        ? Math.max(80, 24 + 16 * Math.max((n.inputs||[]).length, (n.outputs||[]).length))
        : nodeStyle(n.kind).h,
      labels: [{text: n.label}],
      layoutOptions: {'elk.layered.nodePlacement.bk.fixedAlignment': String(rank(n.kind))}
    })),
    edges: EDGES.map(e => ({ id:e.id, sources:[e.source], targets:[e.target],
                              labels:[{text:e.label}], base:e.base||e.label,
                              src_pin:e.src_pin||"", dst_pin:e.dst_pin||"",
                              bundle_idx:e.bundle_idx||0, bundle_n:e.bundle_n||1 }))
  };

  elk.layout(g).then(lg => {
    const svg = document.getElementById('elk');

    // Pan/zoom
    let view = { x:0, y:0, k:1 };
    function applyView(){ svg.setAttribute('viewBox', `${-view.x} ${-view.y} ${(lg.width+80)/view.k} ${(lg.height+80)/view.k}`); }
    applyView();
    let panning=false, start=null;
    svg.addEventListener('mousedown', ev => { if(ev.target===svg){ panning=true; start={x:ev.clientX, y:ev.clientY, vx:view.x, vy:view.y}; }});
    window.addEventListener('mousemove', ev => { if(!panning) return; view.x = start.vx - (ev.clientX - start.x); view.y = start.vy - (ev.clientY - start.y); applyView(); });
    window.addEventListener('mouseup', ()=> panning=false);
    svg.addEventListener('wheel', ev => { ev.preventDefault(); const d = Math.sign(ev.deltaY)*-0.1; view.k = Math.max(0.4, Math.min(2, view.k*(1+d))); applyView(); }, {passive:false});

    // Net details panel
    const netPanel = document.createElement('div');
    netPanel.className = 'section';
    netPanel.innerHTML = '<div class="key">Net details</div><div id="netDetails" class="hint">Click an edge…</div>';
    document.getElementById('sidebar').appendChild(netPanel);
    function showNetDetails(base, items){
      const div = document.getElementById('netDetails');
      div.innerHTML = `<div><b>${base}</b></div>` + items.map(x=>`<div>${x}</div>`).join('');
    }

    const NS = "http://www.w3.org/2000/svg";
    svg.setAttribute('viewBox', `0 0 ${lg.width+80} ${lg.height+80}`);

    const tip = document.getElementById('tip');
    function setTip(x,y,html){ tip.style.left = (x+12)+'px'; tip.style.top = (y+12)+'px'; tip.innerHTML = html; tip.style.opacity = 1; }
    function hideTip(){ tip.style.opacity = 0; }

    // ==== Node drawing & pin anchors ====
    const ANCH = {};  // nodeId -> {in:{pin:y}, out:{pin:y}}
    const NODEGROUPS = new Map(); // nodeId -> <g>

    function recordPin(nodeId, side, pin, y){
      ANCH[nodeId] ||= {in:{}, out:{}};
      ANCH[nodeId][side][pin] = y;
    }

    function drawInstance(n, nodeData){
      const st = nodeStyle('instance');
      const group = document.createElementNS(NS, 'g');
      group.setAttribute('transform', `translate(${n.x+40}, ${n.y+40})`);
      group.setAttribute('data-node-id', n.id);

      const rect = document.createElementNS(NS, 'rect');
      rect.setAttribute('width', n.width); rect.setAttribute('height', n.height);
      rect.setAttribute('fill', st.fill); rect.setAttribute('stroke', st.stroke);
      rect.setAttribute('rx', st.rx); rect.setAttribute('ry', st.rx);
      group.appendChild(rect);

      const t = document.createElementNS(NS, 'text');
      t.setAttribute('x', 8); t.setAttribute('y', 16);
      t.setAttribute('font-size', '12'); t.textContent = nodeData.label;
      group.appendChild(t);

      const ins = nodeData.inputs || [], outs = nodeData.outputs || [];
      const rows = Math.max(ins.length, outs.length);
      const top = 30, rowH = 16;

      for (let i=0;i<rows;i++){
        const y = top + i*rowH;
        if (i < ins.length){
          const pin = ins[i];
          const dotL = document.createElementNS(NS, 'circle');
          dotL.setAttribute('cx', 0); dotL.setAttribute('cy', y); dotL.setAttribute('r', 3);
          dotL.setAttribute('fill', '#70c790'); group.appendChild(dotL);
          const lbl = document.createElementNS(NS, 'text');
          lbl.setAttribute('x', 6); lbl.setAttribute('y', y+4);
          lbl.setAttribute('font-size', '11'); lbl.textContent = pin; group.appendChild(lbl);
          recordPin(n.id, 'in', pin, n.y+40 + y);
        }
        if (i < outs.length){
          const pin = outs[i];
          const dotR = document.createElementNS(NS, 'circle');
          dotR.setAttribute('cx', n.width); dotR.setAttribute('cy', y); dotR.setAttribute('r', 3);
          dotR.setAttribute('fill', '#e6a265'); group.appendChild(dotR);
          const lbl = document.createElementNS(NS, 'text');
          lbl.setAttribute('x', n.width - 6); lbl.setAttribute('y', y+4);
          lbl.setAttribute('font-size', '11'); lbl.setAttribute('text-anchor', 'end');
          lbl.textContent = pin; group.appendChild(lbl);
          recordPin(n.id, 'out', pin, n.y+40 + y);
        }
      }

      svg.appendChild(group);
      NODEGROUPS.set(n.id, group);

      // Node click -> highlight node + all connected edges
      group.addEventListener('click', (ev) => {
        ev.stopPropagation();
        highlightNode(n.id);
      });
    }

    function drawSimple(n, kind){
      const st = nodeStyle(kind);
      const group = document.createElementNS(NS, 'g');
      group.setAttribute('transform', `translate(${n.x+40}, ${n.y+40})`);
      group.setAttribute('data-node-id', n.id);

      const rect = document.createElementNS(NS, 'rect');
      rect.setAttribute('width', n.width); rect.setAttribute('height', n.height);
      rect.setAttribute('fill', st.fill); rect.setAttribute('stroke', st.stroke);
      if (st.rx){ rect.setAttribute('rx', st.rx); rect.setAttribute('ry', st.rx); }
      group.appendChild(rect);

      if (n.labels){
        const t = document.createElementNS(NS, 'text');
        t.setAttribute('x', 8); t.setAttribute('y', 18);
        t.setAttribute('font-size', '12'); t.textContent = n.labels[0].text;
        group.appendChild(t);
      }

      svg.appendChild(group);
      NODEGROUPS.set(n.id, group);

      group.addEventListener('click', (ev) => {
        ev.stopPropagation();
        highlightNode(n.id);
      });
    }

    // Build node map + draw
    const NODEDATA = {};
    for (const n of lg.children){
      const orig = NODES.find(x => x.id === n.id) || {kind:'other', inputs:[], outputs:[], label:n.labels?.[0]?.text || ''};
      NODEDATA[n.id] = { id:n.id, kind:orig.kind, inputs:orig.inputs||[], outputs:orig.outputs||[], label:orig.label,
                         w:n.width, h:n.height, x:n.x+40, y:n.y+40 };
    }
    for (const n of lg.children){
      const nd = NODEDATA[n.id];
      if (nd.kind === 'instance') drawInstance(n, nd);
      else drawSimple(n, nd.kind);
    }

    function rightSidePoint(n){ return { x: n.x + n.w, y: n.y + n.h/2 }; }
    function leftSidePoint(n){ return { x: n.x, y: n.y + n.h/2 }; }
    function getAnchor(nodeId, isSource, pinName){
      const nd = NODEDATA[nodeId];
      if (!nd) return { x: 0, y: 0 };
      if (nd.kind === 'instance' && pinName){
        if (isSource){
          const y = ANCH[nodeId]?.out?.[pinName];
          if (y !== undefined) return { x: nd.x + nd.w, y };
        } else {
          const y = ANCH[nodeId]?.in?.[pinName];
          if (y !== undefined) return { x: nd.x, y };
        }
      }
      return isSource ? rightSidePoint(nd) : leftSidePoint(nd);
    }

    // Arrow marker
    const defs = document.createElementNS(NS, 'defs');
    const marker = document.createElementNS(NS, 'marker');
    marker.setAttribute('id','arrow'); marker.setAttribute('markerWidth','10');
    marker.setAttribute('markerHeight','7'); marker.setAttribute('refX','10');
    marker.setAttribute('refY','3.5'); marker.setAttribute('orient','auto');
    const arrow = document.createElementNS(NS, 'polygon');
    arrow.setAttribute('points','0 0, 10 3.5, 0 7'); arrow.setAttribute('fill','#999');
    marker.appendChild(arrow); defs.appendChild(marker); svg.appendChild(defs);

    // ==== Edge rendering with highlight support ====
    const PATHS = new Set();               // all path elements
    const LABEL_TO_PATH = new Map();       // text -> path
    const EDGES_BY_NODE = new Map();       // nodeId -> Set(path)

    function registerEdgePath(pathEl, sId, tId){
      PATHS.add(pathEl);
      LABEL_TO_PATH.set(pathEl.__labelEl, pathEl);
      (EDGES_BY_NODE.get(sId) || EDGES_BY_NODE.set(sId, new Set()).get(sId)).add(pathEl);
      (EDGES_BY_NODE.get(tId) || EDGES_BY_NODE.set(tId, new Set()).get(tId)).add(pathEl);
    }

    function clearHighlights(){
      [...svg.querySelectorAll('.dim')].forEach(el => el.classList.remove('dim'));
      [...svg.querySelectorAll('.hi-edge')].forEach(el => el.classList.remove('hi-edge'));
      [...svg.querySelectorAll('.hi-node')].forEach(el => el.classList.remove('hi-node'));
      hideTip();
    }

    function applyHighlight(selectedPaths, nodeIds){
      // dim everything
      PATHS.forEach(p => { if (!selectedPaths.has(p)) p.classList.add('dim'); else p.classList.add('hi-edge'); });
      [...svg.querySelectorAll('text[data-edgelabel]')].forEach(lbl => {
        const p = LABEL_TO_PATH.get(lbl);
        if (!selectedPaths.has(p)) lbl.classList.add('dim'); else lbl.classList.remove('dim');
      });
      // nodes
      NODEGROUPS.forEach((g,id) => {
        if (!nodeIds.has(id)) g.classList.add('dim');
        else g.classList.add('hi-node');
      });
    }

    function highlightEdge(pathEl){
      const sId = pathEl.dataset.source, tId = pathEl.dataset.target;
      const selected = new Set([pathEl]);
      const nodes = new Set([sId, tId]);
      applyHighlight(selected, nodes);
    }

    function highlightNode(nodeId){
      const paths = EDGES_BY_NODE.get(nodeId) || new Set();
      const nodes = new Set([nodeId]);
      paths.forEach(p => { nodes.add(p.dataset.source); nodes.add(p.dataset.target); });
      applyHighlight(paths, nodes);
    }

    function renderEdges(){
      // clear old
      [...svg.querySelectorAll('path[data-edge], text[data-edgelabel]')].forEach(el => el.remove());
      PATHS.clear(); LABEL_TO_PATH.clear(); EDGES_BY_NODE.clear();

      const groupBuses = document.getElementById('groupBuses').checked;

      if (groupBuses){
        // Group by (source,target,base)
        const groups = {};
        for (const e of lg.edges){
          const key = `${e.sources[0]}→${e.targets[0]}#${e.base||e.labels?.[0]?.text||''}`;
          (groups[key] ||= []).push(e);
        }
        Object.values(groups).forEach(group => {
          const e = group[0];
          const sId = e.sources[0], tId = e.targets[0];
          const srcPin = e.src_pin?.split('.').slice(-1)[0] || '';
          const dstPin = e.dst_pin?.split('.').slice(-1)[0] || '';
          const s = getAnchor(sId, true,  srcPin);
          const t = getAnchor(tId, false, dstPin);

          const path = document.createElementNS(NS, 'path');
          const d = `M ${s.x} ${s.y} C ${s.x+60} ${s.y}, ${t.x-60} ${t.y}, ${t.x} ${t.y}`;
          path.setAttribute('d', d);
          path.setAttribute('fill','none'); path.setAttribute('stroke','#666'); path.setAttribute('stroke-width','2.2');
          path.setAttribute('marker-end','url(#arrow)');
          path.setAttribute('data-edge','1');
          path.dataset.source = sId; path.dataset.target = tId;

          const base = e.base || e.labels?.[0]?.text || '';
          const lbl = document.createElementNS(NS, 'text');
          const midx = (s.x + t.x) / 2, midy = (s.y + t.y) / 2 - 6;
          lbl.setAttribute('x', midx); lbl.setAttribute('y', midy);
          lbl.setAttribute('font-size','11'); lbl.setAttribute('text-anchor','middle');
          lbl.setAttribute('fill','#444'); lbl.setAttribute('data-edgelabel','1');
          lbl.textContent = `${base} [${group.length}]`;
          path.__labelEl = lbl;

          // Tooltip shows all slice labels with pins
          path.addEventListener('mousemove', ev => {
            const list = group.map(g => {
              const name = g.labels?.[0]?.text || '';
              const meta = (g.src_pin && g.dst_pin) ? `${g.src_pin} → ${g.dst_pin}` : '';
              return `<div>${name}${meta ? ` <span class="hint">(${meta})</span>`:''}</div>`;
            }).join('');
            setTip(ev.clientX, ev.clientY, `<div style="font-weight:600">${base} [${group.length}]</div>${list}`);
          });
          path.addEventListener('mouseleave', hideTip);

          // Click highlight (works in grouped mode)
          path.addEventListener('click', (ev) => {
            ev.stopPropagation();
            clearHighlights();
            highlightEdge(path);
            const items = group.map(g => `${g.labels?.[0]?.text || ''} (${g.src_pin} → ${g.dst_pin})`);
            showNetDetails(base, items);
          });

          svg.appendChild(path); svg.appendChild(lbl);
          registerEdgePath(path, sId, tId);
        });

      } else {
        // Ungrouped: draw all edges, fan between same pair
        const pairGroups = {};
        for (const e of lg.edges){
          const key = e.sources[0] + '→' + e.targets[0];
          (pairGroups[key] ||= []).push(e);
        }
        const OFFSET_STEP = 12;

        Object.values(pairGroups).forEach(group => {
          const n = group.length;
          group.forEach((e, k) => {
            const sId = e.sources[0], tId = e.targets[0];
            const srcPin = e.src_pin?.split('.').slice(-1)[0] || '';
            const dstPin = e.dst_pin?.split('.').slice(-1)[0] || '';
            const s = getAnchor(sId, true,  srcPin);
            const t = getAnchor(tId, false, dstPin);
            const offset = (k - (n-1)/2) * OFFSET_STEP;

            const path = document.createElementNS(NS, 'path');
            const c1x = s.x + 60, c1y = s.y + offset;
            const c2x = t.x - 60, c2y = t.y + offset;
            const d = `M ${s.x} ${s.y} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${t.x} ${t.y}`;
            path.setAttribute('d', d);
            path.setAttribute('fill','none'); path.setAttribute('stroke','#999'); path.setAttribute('stroke-width','1.5');
            path.setAttribute('marker-end','url(#arrow)');
            path.setAttribute('data-edge','1');
            path.dataset.edgeId = e.id;
            path.dataset.source = sId; path.dataset.target = tId;

            const midx = (s.x + t.x) / 2, midy = (s.y + t.y) / 2 + offset - 6;
            const lbl = document.createElementNS(NS, 'text');
            lbl.setAttribute('x', midx); lbl.setAttribute('y', midy);
            lbl.setAttribute('font-size','11'); lbl.setAttribute('text-anchor','middle');
            lbl.setAttribute('fill','#555'); lbl.setAttribute('data-edgelabel','1');
            lbl.textContent = e.labels?.[0]?.text || '';
            path.__labelEl = lbl;

            path.addEventListener('mousemove', ev => {
              const meta = (e.src_pin && e.dst_pin) ? `${e.src_pin} → ${e.dst_pin}` : '';
              setTip(ev.clientX, ev.clientY, `<div style="font-weight:600">${lbl.textContent}</div>${meta ? `<div class="hint">${meta}</div>`:''}`);
            });
            path.addEventListener('mouseleave', hideTip);
            path.addEventListener('click', (ev) => {
              ev.stopPropagation();
              clearHighlights();
              highlightEdge(path);
              showNetDetails(e.base || lbl.textContent, [`${lbl.textContent} (${e.src_pin} → ${e.dst_pin})`]);
            });

            svg.appendChild(path); svg.appendChild(lbl);
            registerEdgePath(path, sId, tId);
          });
        });
      }
    }

    renderEdges();

    // Interactions
    document.getElementById('groupBuses').addEventListener('change', () => { clearHighlights(); renderEdges(); });
    document.getElementById('resetView').addEventListener('click', clearHighlights);
    svg.addEventListener('click', clearHighlights); // background click clears
    window.addEventListener('keydown', e => { if (e.key === 'Escape') clearHighlights(); });
  });
</script>
</body>
</html>
