<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>VHDL Visualizer â€“ Block</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    html, body { height: 100%; margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, sans-serif; }
    #app { display:grid; grid-template-columns: 320px 1fr; height:100%; }
    #sidebar { border-right:1px solid #ddd; padding:12px; overflow:auto; }
    #canvas { position:relative; }
    #elk { width: 100%; height: 100%; }
    .section { margin: 12px 0; }
    .tag { display:inline-block; padding:2px 6px; border:1px solid #ddd; border-radius:6px; margin:2px; font-size:12px; }
    .key { font-weight:600; }
    .hint { color:#666; font-size:12px; }
  </style>
  <script src="https://unpkg.com/elkjs@0.9.3/lib/elk.bundled.js"></script>
  <script>
    const DATA = /*__BLOCK_DATA__*/
  </script>
</head>
<body>
<div id="app">
  <div id="sidebar">
    <div class="section"><span class="key">Block:</span> <span id="ent"></span></div>
    <div class="section"><div class="key">File</div><div><code id="path"></code></div></div>
    <div class="section">
      <div class="key">Ports</div><div id="ports"></div>
    </div>
    <div class="section">
      <div class="key">Signals</div><div id="signals"></div>
    </div>
    <div class="section">
      <div class="key">Instances</div><div id="instances"></div>
    </div>
    <div class="section hint">Edges show real nets; labels are internal signal / expression names.</div>
  </div>
  <div id="canvas"><svg id="elk"></svg></div>
</div>

<script>
  document.getElementById('ent').textContent = DATA.file.entity;
  document.getElementById('path').textContent = DATA.file.path;
  const portsDiv = document.getElementById('ports');
  DATA.ports.forEach(p => {
    const span = document.createElement('span'); span.className='tag';
    span.textContent = `${p.name}: ${p.direction} ${p.dtype}`; portsDiv.appendChild(span);
  });
  const sigDiv = document.getElementById('signals');
  DATA.signals.forEach(s => {
    const span = document.createElement('span'); span.className='tag';
    span.textContent = `${s.name}: ${s.dtype}`; sigDiv.appendChild(span);
  });
  const instDiv = document.getElementById('instances');
  DATA.instances.forEach(i => {
    const div = document.createElement('div'); div.style.margin='6px 0';
    const head = document.createElement('div');
    head.innerHTML = `<span class="key">${i.label}</span> : ${(i.entity_ref||i.component_name||'?')}`;
    div.appendChild(head);
    if (i.port_map && Object.keys(i.port_map).length) {
      const pm = document.createElement('div'); pm.style.fontSize='12px'; pm.style.color='#333';
      pm.textContent = Object.entries(i.port_map).map(([k,v])=>`${k}=>${v}`).join(', ');
      div.appendChild(pm);
    }
    instDiv.appendChild(div);
  });

  // Build ELK graph from DATA.graph
  const elk = new ELK();
  const NODES = DATA.graph.nodes;
  const EDGES = DATA.graph.edges;

  // Map node styling by kind
  function nodeStyle(kind){
    if (kind === 'instance') return {w: 180, h: 60, fill:'#eef3ff', stroke:'#99b2ff', rx:12};
    if (kind === 'entity_in') return {w: 130, h: 30, fill:'#e8fff1', stroke:'#70c790', rx:10};
    if (kind === 'entity_out') return {w: 130, h: 30, fill:'#fff1e8', stroke:'#e6a265', rx:10};
    if (kind === 'entity_bi') return {w: 130, h: 30, fill:'#fffbe6', stroke:'#d0c05a', rx:10};
    if (kind === 'const') return {w: 90, h: 26, fill:'#f4f4f4', stroke:'#bbb', rx:10};
    if (kind === 'expr') return {w: 150, h: 26, fill:'#f9f9f9', stroke:'#bbb', rx:10};
    return {w: 120, h: 30, fill:'#f4f4f4', stroke:'#bbb', rx:10};
  }

  // Heuristic ranks to encourage left->right flow
  function rank(kind){
    if (kind === 'entity_in' || kind === 'const' || kind === 'expr') return 0;
    if (kind === 'instance') return 1;
    if (kind === 'entity_out' || kind === 'entity_bi') return 2;
    return 1;
  }

  const g = {
    id: "root",
    layoutOptions: {
      'elk.algorithm': 'layered',
      'elk.direction': 'RIGHT',
      'elk.layered.spacing.nodeNodeBetweenLayers': '80',
      'elk.spacing.componentComponent': '60',
      'elk.edgeRouting': 'SPLINES'
    },
    children: NODES.map(n => ({
      id: n.id,
      width: nodeStyle(n.kind).w,
      height: nodeStyle(n.kind).h,
      labels: [{text: n.label}],
      layoutOptions: {'elk.layered.nodePlacement.bk.fixedAlignment': String(rank(n.kind))}
    })),
    edges: EDGES.map(e => ({ id: e.id, sources:[e.source], targets:[e.target], labels:[{text: e.label}] }))
  };

  elk.layout(g).then(lg => {
    const svg = document.getElementById('elk');
    const NS = "http://www.w3.org/2000/svg";
    svg.setAttribute('viewBox', `0 0 ${lg.width+60} ${lg.height+60}`);

    function drawNode(n) {
      const nodeData = NODES.find(x => x.id === n.id) || {kind:'other'};
      const st = nodeStyle(nodeData.kind);
      const group = document.createElementNS(NS, 'g');
      group.setAttribute('transform', `translate(${n.x+30}, ${n.y+30})`);
      const rect = document.createElementNS(NS, 'rect');
      rect.setAttribute('rx', st.rx); rect.setAttribute('ry', st.rx);
      rect.setAttribute('width', n.width); rect.setAttribute('height', n.height);
      rect.setAttribute('fill', st.fill); rect.setAttribute('stroke', st.stroke);
      group.appendChild(rect);
      if (n.labels) {
        n.labels.forEach((l, idx) => {
          const t = document.createElementNS(NS, 'text');
          t.setAttribute('x', 8); t.setAttribute('y', 18 + idx*14);
          t.setAttribute('font-size', '12');
          t.textContent = l.text;
          group.appendChild(t);
        });
      }
      svg.appendChild(group);
    }

    function centerOf(n) { return { x: n.x+30+n.width/2, y: n.y+30+n.height/2 }; }
    function find(id) { return lg.children.find(c => c.id===id); }

    // Draw edges first (so labels go under nodes), but it's fine either way
    lg.edges.forEach(e => {
      const s = find(e.sources[0]), t = find(e.targets[0]);
      if (!s || !t) return;
      const p1 = centerOf(s), p2 = centerOf(t);
      const path = document.createElementNS(NS, 'path');
      const d = `M ${p1.x} ${p1.y} C ${p1.x+60} ${p1.y}, ${p2.x-60} ${p2.y}, ${p2.x} ${p2.y}`;
      path.setAttribute('d', d);
      path.setAttribute('fill', 'none');
      path.setAttribute('stroke', '#bbb');
      path.setAttribute('stroke-width', '1.5');
      path.setAttribute('marker-end', 'url(#arrow)');
      svg.appendChild(path);

      // Edge label
      if (e.labels && e.labels[0] && e.labels[0].text) {
        const midx = (p1.x + p2.x) / 2, midy = (p1.y + p2.y) / 2;
        const lbl = document.createElementNS(NS, 'text');
        lbl.setAttribute('x', midx); lbl.setAttribute('y', midy - 6);
        lbl.setAttribute('font-size', '11'); lbl.setAttribute('text-anchor', 'middle');
        lbl.setAttribute('fill', '#555');
        lbl.textContent = e.labels[0].text;
        svg.appendChild(lbl);
      }
    });

    // Arrow marker
    const defs = document.createElementNS(NS, 'defs');
    const marker = document.createElementNS(NS, 'marker');
    marker.setAttribute('id', 'arrow'); marker.setAttribute('markerWidth', '10');
    marker.setAttribute('markerHeight', '7'); marker.setAttribute('refX', '10');
    marker.setAttribute('refY', '3.5'); marker.setAttribute('orient', 'auto');
    const arrow = document.createElementNS(NS, 'polygon');
    arrow.setAttribute('points', '0 0, 10 3.5, 0 7'); arrow.setAttribute('fill', '#bbb');
    marker.appendChild(arrow); defs.appendChild(marker); svg.appendChild(defs);

    // Draw nodes on top
    lg.children.forEach(drawNode);
  });
</script>
</body>
</html>
