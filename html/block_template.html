<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>VHDL Visualizer – Block</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    html, body { height: 100%; margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, sans-serif; }
    #app { display:grid; grid-template-columns: 320px 1fr; height:100%; }
    #sidebar { border-right:1px solid #ddd; padding:12px; overflow:auto; }
    #canvas { position:relative; }
    #elk { width: 100%; height: 100%; }
    .section { margin: 12px 0; }
    .tag { display:inline-block; padding:2px 6px; border:1px solid #ddd; border-radius:6px; margin:2px; font-size:12px; }
    .key { font-weight:600; }
    .hint { color:#666; font-size:12px; }
    /* Tooltip */
    #tip { position: fixed; pointer-events: none; background: #111; color:#fff; padding:6px 8px; border-radius:6px; font-size:12px; opacity:0; transition:opacity .08s ease; max-width: 420px; }
    .muted { color:#777 }
  </style>
  <script src="https://unpkg.com/elkjs@0.9.3/lib/elk.bundled.js"></script>
  <script> const DATA = /*__BLOCK_DATA__*/ </script>
</head>
<body>
<div id="app">
  <div id="sidebar">
    <div class="section"><span class="key">Block:</span> <span id="ent"></span></div>
    <div class="section"><div class="key">File</div><div><code id="path"></code></div></div>
    <div class="section">
      <div class="key">Ports</div><div id="ports"></div>
    </div>
    <div class="section">
      <div class="key">Signals</div><div id="signals"></div>
    </div>
    <div class="section">
      <div class="key">Instances</div><div id="instances"></div>
    </div>
    <div class="section hint">Hover edges to see exact pins; multiple wires between the same blocks are fanned with slight offsets. Net hubs (•) reduce clutter.</div>
  </div>
  <div id="canvas"><svg id="elk"></svg></div>
</div>
<div id="tip"></div>
<script>
  // Sidebar
  ent.textContent = DATA.file.entity;
  path.textContent = DATA.file.path;
  DATA.ports.forEach(p => { const s=document.createElement('span'); s.className='tag'; s.textContent=`${p.name}: ${p.direction} ${p.dtype}`; ports.appendChild(s); });
  DATA.signals.forEach(sg => { const s=document.createElement('span'); s.className='tag'; s.textContent=`${sg.name}: ${sg.dtype}`; signals.appendChild(s); });
  DATA.instances.forEach(i => {
    const div=document.createElement('div'); div.style.margin='6px 0';
    const head=document.createElement('div');
    head.innerHTML=`<span class="key">${i.label}</span> : ${(i.entity_ref||i.component_name||'?')}`;
    div.appendChild(head);
    if (i.port_map && Object.keys(i.port_map).length){
      const pm=document.createElement('div'); pm.style.fontSize='12px'; pm.style.color='#333';
      pm.textContent=Object.entries(i.port_map).map(([k,v])=>`${k}=>${v}`).join(', ');
      div.appendChild(pm);
    }
    instances.appendChild(div);
  });

  // ELK graph data
  const NODES = DATA.graph.nodes;
  const EDGES = DATA.graph.edges;

  // Node styles + rank for left->right
  function nodeStyle(kind){
    if (kind === 'instance') return {w: 190, h: 64, fill:'#eef3ff', stroke:'#99b2ff', rx:12};
    if (kind === 'entity_in') return {w: 140, h: 30, fill:'#e8fff1', stroke:'#70c790', rx:10};
    if (kind === 'entity_out') return {w: 140, h: 30, fill:'#fff1e8', stroke:'#e6a265', rx:10};
    if (kind === 'entity_bi') return {w: 140, h: 30, fill:'#fffbe6', stroke:'#d0c05a', rx:10};
    if (kind === 'const') return {w: 90, h: 26, fill:'#f4f4f4', stroke:'#bbb', rx:10};
    if (kind === 'expr') return {w: 170, h: 26, fill:'#f9f9f9', stroke:'#bbb', rx:10};
    if (kind === 'net') return {w: 14, h: 14, fill:'#fff', stroke:'#777', rx:7, isCircle:true};
    return {w: 120, h: 30, fill:'#f4f4f4', stroke:'#bbb', rx:10};
  }
  function rank(kind){
    if (kind === 'entity_in' || kind === 'const' || kind === 'expr') return 0;
    if (kind === 'net' || kind === 'instance') return 1;
    if (kind === 'entity_out' || kind === 'entity_bi') return 2;
    return 1;
  }

  // Build ELK layout
  const elk = new ELK();
  const g = {
    id: "root",
    layoutOptions: {
      'elk.algorithm':'layered',
      'elk.direction':'RIGHT',
      'elk.layered.spacing.nodeNodeBetweenLayers':'90',
      'elk.spacing.componentComponent':'70',
      'elk.edgeRouting':'SPLINES'
    },
    children: NODES.map(n => ({
      id: n.id,
      width: nodeStyle(n.kind).w,
      height: nodeStyle(n.kind).h,
      labels: [{text: n.label}],
      layoutOptions: {'elk.layered.nodePlacement.bk.fixedAlignment': String(rank(n.kind))}
    })),
    edges: EDGES.map(e => ({ id:e.id, sources:[e.source], targets:[e.target], labels:[{text:e.label}],
                              bundle_idx: e.bundle_idx||0, bundle_n: e.bundle_n||1, meta:e.meta||"", base:e.base||e.label }))
  };

  elk.layout(g).then(lg => {
    const svg = document.getElementById('elk');
    const NS = "http://www.w3.org/2000/svg";
    svg.setAttribute('viewBox', `0 0 ${lg.width+80} ${lg.height+80}`);

    // Helpers
    function drawNode(n) {
      const nodeData = NODES.find(x => x.id === n.id) || {kind:'other'};
      const st = nodeStyle(nodeData.kind);
      const group = document.createElementNS(NS, 'g');
      group.setAttribute('transform', `translate(${n.x+40}, ${n.y+40})`);
      const rect = document.createElementNS(NS, 'rect');
      rect.setAttribute('width', n.width); rect.setAttribute('height', n.height);
      rect.setAttribute('fill', st.fill); rect.setAttribute('stroke', st.stroke);
      if (st.rx) { rect.setAttribute('rx', st.rx); rect.setAttribute('ry', st.rx); }
      if (st.isCircle) { // draw as circle
        rect.setAttribute('rx', n.width/2); rect.setAttribute('ry', n.height/2);
      }
      group.appendChild(rect);
      if (n.labels) n.labels.forEach((l, idx) => {
        const t = document.createElementNS(NS, 'text');
        t.setAttribute('x', st.isCircle ? (n.width/2 - 3) : 8);
        t.setAttribute('y', st.isCircle ? (n.height/2 + 4) : (18 + idx*14));
        t.setAttribute('font-size', st.isCircle ? '10' : '12');
        t.setAttribute('text-anchor', st.isCircle ? 'middle' : 'start');
        t.textContent = st.isCircle ? '•' : l.text;
        group.appendChild(t);
      });
      svg.appendChild(group);
    }
    function centerOf(n) { return { x: n.x+40+n.width/2, y: n.y+40+n.height/2 }; }
    function sidePoint(n, which){ // which: 'L' or 'R'
      const y = n.y+40+n.height/2;
      return { x: which==='L' ? (n.x+40) : (n.x+40+n.width), y };
    }
    function find(id){ return lg.children.find(c => c.id===id); }

    // Pre-draw nodes (for coordinates)
    lg.children.forEach(drawNode);

    // Arrow marker
    const defs = document.createElementNS(NS, 'defs');
    const marker = document.createElementNS(NS, 'marker');
    marker.setAttribute('id','arrow'); marker.setAttribute('markerWidth','10');
    marker.setAttribute('markerHeight','7'); marker.setAttribute('refX','10');
    marker.setAttribute('refY','3.5'); marker.setAttribute('orient','auto');
    const arrow = document.createElementNS(NS, 'polygon');
    arrow.setAttribute('points','0 0, 10 3.5, 0 7'); arrow.setAttribute('fill','#999');
    marker.appendChild(arrow); defs.appendChild(marker); svg.appendChild(defs);

    // Group edges by (source,target) for offsetting
    const groups = {};
    lg.edges.forEach((e,i) => {
      const key = e.sources[0] + '→' + e.targets[0];
      (groups[key] ||= []).push(e);
    });

    // Draw edges with per-group offsets
    const OFFSET_STEP = 12;
    const tip = document.getElementById('tip');

    function setTip(x,y,html){ tip.style.left = (x+12)+'px'; tip.style.top = (y+12)+'px'; tip.innerHTML = html; tip.style.opacity = 1; }
    function hideTip(){ tip.style.opacity = 0; }

    Object.values(groups).forEach(group => {
      const n = group.length;
      group.forEach((e, k) => {
        const s = find(e.sources[0]), t = find(e.targets[0]);
        if (!s || !t) return;
        const sp = sidePoint(s, 'R'), tp = sidePoint(t, 'L');

        // fan edges: spread control points vertically
        const idx = k; // use layout-provided order
        const offset = (idx - (n-1)/2) * OFFSET_STEP;

        const path = document.createElementNS(NS, 'path');
        const c1x = sp.x + 60, c1y = sp.y + offset;
        const c2x = tp.x - 60, c2y = tp.y + offset;
        const d = `M ${sp.x} ${sp.y} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${tp.x} ${tp.y}`;
        path.setAttribute('d', d);
        path.setAttribute('fill', 'none');
        path.setAttribute('stroke', '#999');
        path.setAttribute('stroke-width', '1.5');
        path.setAttribute('marker-end','url(#arrow)');
        path.dataset.label = e.labels?.[0]?.text || '';
        path.dataset.meta  = e.meta || '';
        path.dataset.base  = e.base || path.dataset.label;

        // lightweight edge label: draw near middle with small vertical offset
        const midx = (sp.x + tp.x) / 2;
        const midy = (sp.y + tp.y) / 2 + offset - 6;
        const lbl = document.createElementNS(NS, 'text');
        lbl.setAttribute('x', midx); lbl.setAttribute('y', midy);
        lbl.setAttribute('font-size','11'); lbl.setAttribute('text-anchor','middle');
        lbl.setAttribute('fill','#555');
        lbl.textContent = path.dataset.label;

        // Tooltip (bundle summary: show all labels in the group)
        path.addEventListener('mousemove', ev => {
          const labels = group.map(g => g.labels?.[0]?.text || '').filter(Boolean);
          const pins   = group.map(g => g.meta || '').filter(Boolean);
          const uniqBase = [...new Set(group.map(g => g.base || ''))].filter(Boolean);
          const title = uniqBase.length === 1 ? uniqBase[0] : (labels.length > 1 ? `${labels.length} signals` : labels[0]);
          const list  = labels.map((l, i) => `<div>${l}${pins[i] ? ` <span class="muted">(${pins[i]})</span>`:''}</div>`).join('');
          setTip(ev.clientX, ev.clientY, `<div style="font-weight:600">${title}</div>${list}`);
        });
        path.addEventListener('mouseleave', hideTip);

        svg.appendChild(path);
        svg.appendChild(lbl);
      });
    });
  });
</script>
</body>
</html>
