<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>VHDL Visualizer</title>
    <style>
        :root {
            --bg: #0e1116;
            --fg: #e5e7eb;
            --muted: #9aa4b2;
            --accent: #60a5fa;
            --box: #1b2230;
            --line: #3b82f6;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            background: var(--bg);
            color: var(--fg);
            font: 14px/1.35 system-ui, Segoe UI, Inter, Roboto, sans-serif;
        }

        header {
            padding: 12px 16px;
            border-bottom: 1px solid #1f2937;
            display: flex;
            gap: 16px;
            align-items: center;
        }

        header h1 {
            font-size: 16px;
            margin: 0;
        }

        #wrap {
            display: grid;
            grid-template-columns: 1fr 380px;
            height: calc(100% - 50px);
        }

        #left {
            position: relative;
        }

        #right {
            border-left: 1px solid #1f2937;
            overflow: auto;
        }

        #dep,
        #struct {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
        }

        .panel {
            padding: 12px;
        }

        .muted {
            color: var(--muted);
        }

        .pill {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 999px;
            background: #111827;
            color: var(--muted);
            font-size: 12px;
            margin-left: 6px;
        }

        button {
            background: #111827;
            border: 1px solid #374151;
            color: var(--fg);
            padding: 6px 10px;
            border-radius: 8px;
            cursor: pointer;
        }

        button:hover {
            background: #0b1220;
        }

        .box {
            fill: var(--box);
            stroke: #2b3950;
            stroke-width: 1;
            rx: 10;
        }

        .sig {
            stroke: #6b7280;
            stroke-width: 1;
        }

        .inst {
            stroke: var(--line);
            stroke-width: 1;
        }

        .label {
            font-size: 12px;
            fill: var(--fg);
        }

        .tiny {
            font-size: 11px;
            fill: var(--muted);
        }

        .list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .list li {
            padding: 8px 0;
            border-bottom: 1px solid #111827;
        }

        .k {
            color: #93c5fd;
        }

        .v {
            color: #a7f3d0;
        }

        a {
            color: var(--accent);
            text-decoration: none;
        }
    </style>
    <!-- D3 from CDN; if offline, dependency graph will degrade to a simple list -->
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
</head>

<body>
    <header>
        <h1>VHDL Visualizer <span class="pill" id="meta"></span></h1>
        <button id="btn-dep">Dependency Graph</button>
        <button id="btn-struct">File Structure</button>
    </header>
    <!-- Toolbar for graph spacing -->
    <div style="padding:8px 12px; border-bottom:1px solid #1f2937; display:flex; gap:12px; align-items:center;">
        <div class="tiny" style="margin-right:6px;">Node spacing</div>
        <input id="space" type="range" min="80" max="320" value="160" step="10" style="width:220px" />
        <button id="btn-relayout">Relayout</button>
    </div>
    <div id="wrap">
        <div id="left">
            <svg id="dep"></svg>
            <svg id="struct" style="display:none"></svg>
        </div>
        <aside id="right">
            <div class="panel">
                <h3>Selection</h3>
                <div id="sel" class="muted">Click a file node to inspect structure.</div>
                <h3 style="margin-top:20px">Files</h3>
                <ul id="files" class="list"></ul>
            </div>
        </aside>
    </div>
    <script>
        const DATA = /*__DATA__*/;

        // ---- Helpers & Elements ----
        const $ = (q) => document.querySelector(q);
        function fname(p) {
            const parts = String(p).split(/[\/\\]/);
            return parts[parts.length - 1] || String(p);
        }

        const depSVG = d3.select('#dep');
        const structSVG = d3.select('#struct');
        const LEFT = document.getElementById('left');
        let CURRENT_PATH = null;

        const meta = $('#meta');
        const filesList = $('#files');
        const sel = $('#sel');
        const search = $('#search');
        const spaceCtl = $('#space');
        const btnRelayout = $('#btn-relayout');
        window.FILE_ITEMS = []; // {path,name,li}
        function getSpacing() { return spaceCtl ? (+spaceCtl.value || 160) : 160; } // {path,name,li}

        // Guard against missing data
        if (!DATA || !Array.isArray(DATA.files)) {
            sel.textContent = 'No data found in payload.';
        }

        meta.textContent = `${(DATA.files || []).length} files, ${(DATA.deps || []).length} deps`;

        // ---- Build Files List ----
        filesList.innerHTML = '';
        for (const f of (DATA.files || [])) {
            const li = document.createElement('li');
            const name = fname(f.path);
            li.dataset.name = name.toLowerCase();
            const a = document.createElement('a'); a.href = '#'; a.textContent = name;
            a.title = f.path; a.onclick = (e) => { e.preventDefault(); showStruct(f.path); };
            li.appendChild(a);
            const info = document.createElement('div');
            info.className = 'tiny';
            info.textContent = `${(f.entities || []).length} ent, ${f.num_instances || 0} inst, ${f.num_signals || 0} sig`;
            li.appendChild(info);
            filesList.appendChild(li);
            window.FILE_ITEMS.push({ path: f.path, name, li });
        }

        // ---- Dependency Graph ----
        let DEP_CTX = null; // store selections for highlighting
        function drawDeps() {
            const rect = LEFT.getBoundingClientRect();
            const w = Math.max(100, rect.width);
            const h = Math.max(100, rect.height);
            depSVG.attr('viewBox', `0 0 ${w} ${h}`).attr('width', w).attr('height', h);
            depSVG.selectAll('*').remove();
            if (!window.d3) {
                depSVG.append('text').attr('x', 10).attr('y', 20).text('d3 not available (offline)');
                return;
            }
            const nodesById = new Map();
            const nodes = (DATA.files || []).map((f, i) => { const cols = Math.max(1, Math.floor(Math.sqrt((DATA.files || []).length))); const col = i % cols, row = Math.floor(i / cols); const gx = (w / (cols + 1)) * (col + 1), gy = (h / (Math.ceil((DATA.files || []).length / cols) + 1)) * (row + 1); const n = { id: f.path, file: f, x: gx + (Math.random() - 0.5) * 20, y: gy + (Math.random() - 0.5) * 20 }; nodesById.set(n.id, n); return n; });
            const links = (DATA.deps || []).map(d => ({ source: d.source, target: d.target, via: d.via }));

            const s = getSpacing();
            const sim = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(s).strength(0.3))
                .force('charge', d3.forceManyBody().strength(-1.2 * s))
                .force('center', d3.forceCenter(w / 2, h / 2))
                .force('collide', d3.forceCollide().radius(Math.max(22, s * 0.22)).iterations(2));
            sim.velocityDecay(0.9);

            const container = depSVG.append('g');
            // Zoom & pan
            const zoomBehavior = d3.zoom().scaleExtent([0.2, 5]).on('zoom', (event) => {
                container.attr('transform', event.transform);
            });
            depSVG.call(zoomBehavior);

            const link = container.selectAll('line').data(links).enter().append('line').attr('stroke', '#334155').attr('stroke-width', 1).attr('opacity', 0.8);
            const label = container.selectAll('text.via').data(links).enter().append('text').attr('class', 'tiny').attr('fill', '#94a3b8').text(d => d.via || '');
            const node = container.selectAll('g.node').data(nodes).enter().append('g').attr('class', 'node').call(drag(sim));
            node.append('circle').attr('r', 18).attr('fill', '#1f2937').attr('stroke', '#60a5fa');
            node.append('text').attr('class', 'label').attr('text-anchor', 'middle').attr('dy', 4).text(d => fname(d.file.path));
            node.on('click', (e, d) => { showStruct(d.file.path); });
            node.on('dblclick', (e, d) => { // pin/unpin
                if (d.fx == null) { d.fx = d.x; d.fy = d.y; }
                else { d.fx = null; d.fy = null; }
            });

            sim.on('tick', () => {
                link.attr('x1', d => d.source.x).attr('y1', d => d.source.y).attr('x2', d => d.target.x).attr('y2', d => d.target.y);
                label.attr('x', d => (d.source.x + d.target.x) / 2).attr('y', d => (d.source.y + d.target.y) / 2);
                node.attr('transform', d => `translate(${d.x},${d.y})`);
            });

            // Reduce floatiness: let layout settle, then stop forces
            setTimeout(() => {
                sim.alphaTarget(0); sim.stop();
                // Zoom-to-fit after layout settles
                const xs = nodes.map(n => n.x), ys = nodes.map(n => n.y);
                const minX = Math.min(...xs), maxX = Math.max(...xs), minY = Math.min(...ys), maxY = Math.max(...ys);
                const bw = Math.max(10, maxX - minX), bh = Math.max(10, maxY - minY);
                const k = 0.9 * Math.min(w / bw, h / bh);
                const tx = (w - k * (minX + maxX)) / 2; const ty = (h - k * (minY + maxY)) / 2;
                depSVG.transition().duration(350).call(zoomBehavior.transform, d3.zoomIdentity.translate(tx, ty).scale(k));
            }, 1200);

            DEP_CTX = { node, link, label, nodes, links };
            applySearchFilter(search ? search.value : '');

            function drag(sim) {
                function started(event, d) { if (!event.active) sim.alphaTarget(0.3).restart(); if (event.sourceEvent && event.sourceEvent.stopPropagation) event.sourceEvent.stopPropagation(); d.fx = d.x; d.fy = d.y; }
                function dragged(event, d) { d.fx = event.x; d.fy = event.y; }
                function ended(event, d) { if (!event.active) sim.alphaTarget(0); }
                return d3.drag().on('start', started).on('drag', dragged).on('end', ended);
            }
        }

        // ---- Structure (per file) ----
        function showStruct(path) {
            CURRENT_PATH = path;
            $('#btn-struct').click();
            const model = DATA.structures[path];
            if (!model) { sel.textContent = 'No structure for ' + path; return; }
            sel.innerHTML = `<div><span class="k">file</span>: <span class="v">${path}</span></div>`;
            drawStruct(path, model);
        }

        function drawStruct(path, model) {
            const rect = LEFT.getBoundingClientRect();
            const w = Math.max(100, rect.width);
            const h = Math.max(100, rect.height);
            structSVG.attr('viewBox', `0 0 ${w} ${h}`).attr('width', w).attr('height', h);
            structSVG.selectAll('*').remove();

            const P = { left: 24, top: 24, colGap: 24, rowH: 64, boxW: 220, boxH: 40 };
            const instances = model.instances || [];
            const signals = Object.entries(model.signals || {});

            const g = structSVG.append('g');

            const sigX = P.left, sigW = 200;
            g.append('text').attr('x', sigX).attr('y', P.top - 6).attr('class', 'tiny').text('signals');
            signals.slice(0, 200).forEach(([name, typ], i) => {
                const y = P.top + 20 + i * 18;
                g.append('text').attr('x', sigX).attr('y', y).attr('class', 'tiny').text(`${name}: ${typ}`);
            });

            const instCols = Math.max(1, Math.floor((w - sigW - 3 * P.left) / (P.boxW + P.colGap)));
            const instX0 = sigX + sigW + P.left;
            const instG = g.append('g');
            const instPos = {};
            instances.forEach((inst, i) => {
                const col = i % instCols;
                const row = Math.floor(i / instCols);
                const x = instX0 + col * (P.boxW + P.colGap);
                const y = P.top + row * (P.boxH + P.rowH);
                instPos[inst.label] = { x: x, y: y };
                instG.append('rect').attr('x', x).attr('y', y).attr('width', P.boxW).attr('height', P.boxH).attr('class', 'box inst');
                instG.append('text').attr('x', x + 10).attr('y', y + 16).attr('class', 'label').text(`${inst.label}: ${inst.type}`);
                instG.append('text').attr('x', x + 10).attr('y', y + 32).attr('class', 'tiny').text(inst.kind);
                let k = 0; for (const [f, a] of Object.entries(inst.ports || {}).slice(0, 4)) {
                    instG.append('text').attr('x', x + 10).attr('y', y + 48 + 14 * k).attr('class', 'tiny').text(`${f} => ${a}`); k++;
                }
            });

            const sigIndex = {};
            let i = 0; signals.forEach(([name, typ]) => { sigIndex[name] = i++; });

            const lineG = g.append('g');
            instances.forEach(inst => {
                for (const [f, a] of Object.entries(inst.ports || {})) {
                    if (sigIndex[a] !== undefined) {
                        const ip = instPos[inst.label];
                        const ySig = P.top + 20 + sigIndex[a] * 18 - 6;
                        const xSig = sigX + 160;
                        const xBox = ip.x + P.boxW / 2;
                        const yBox = ip.y + P.boxH;
                        lineG.append('path').attr('d', `M${xSig},${ySig} C ${xSig + 60},${ySig} ${xBox - 60},${yBox} ${xBox},${yBox}`)
                            .attr('fill', 'none').attr('class', 'sig');
                    }
                }
            });
        }

        // ---- Search ----
        function filterFiles(q) {
            const s = (q || '').toLowerCase().trim();
            for (const item of window.FILE_ITEMS) { item.li.style.display = (!s || item.name.toLowerCase().includes(s)) ? '' : 'none'; }
        }
        function applySearchFilter(q) {
            if (!DEP_CTX) return;
            const s = (q || '').toLowerCase().trim();
            const ok = new Set();
            if (s) { for (const it of window.FILE_ITEMS) { if (it.name.toLowerCase().includes(s)) ok.add(it.path); } }
            const showAll = !s || ok.size === 0;
            DEP_CTX.node.attr('opacity', d => showAll || ok.has(d.file.path) ? 1 : 0.15);
            DEP_CTX.link.attr('opacity', d => {
                const a = d.source.id || d.source; const b = d.target.id || d.target;
                return showAll || (ok.has(a) && ok.has(b)) ? 0.8 : 0.1;
            });
        }
        if (search) { search.addEventListener('input', () => { filterFiles(search.value); applySearchFilter(search.value); }); }

        // ---- Buttons & Init ----
        $('#btn-dep').onclick = () => { depSVG.style('display', null); structSVG.style('display', 'none'); drawDeps(); };
        $('#btn-struct').onclick = () => { depSVG.style('display', 'none'); structSVG.style('display', null); structSVG.selectAll('*').remove(); };
        $('#btn-dep').click();

        if (spaceCtl) { spaceCtl.addEventListener('input', () => { if (depSVG.style('display') !== 'none') drawDeps(); }); }
        if (btnRelayout) { btnRelayout.addEventListener('click', () => { if (depSVG.style('display') !== 'none') drawDeps(); }); }

        // ---- Resize ----
        window.addEventListener('resize', () => {
            const depVisible = depSVG.style('display') !== 'none';
            if (depVisible) drawDeps();
            else if (CURRENT_PATH) drawStruct(CURRENT_PATH, DATA.structures[CURRENT_PATH]);
        });

    </script>
</body>

</html>